<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="format-detection" content="telephone=no">

  <title>Mappa Mentale Mobile</title>
  
  <style>
    :root {
      --bg: #f6f7fb;
      --grid: rgba(0,0,0,.06);
      --ink: #1a1a1a;
      --accent: #0078ff;
      /* SAFE AREAS: Variabili per gestire la "tacca" e la barra home in basso */
      --safe-top: env(safe-area-inset-top, 20px);
      --safe-bottom: env(safe-area-inset-bottom, 20px);
      --controls-bottom: calc(20px + var(--safe-bottom));
    }

    /* SETUP PAGINA: overflow hidden e position fixed impediscono lo scroll elastico dell'intera pagina */
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
      color: var(--ink);
      overflow: hidden; 
      position: fixed;
      width: 100%;
      background: var(--bg);
    }

    #app { 
      height: 100dvh; /* Usa l'altezza dinamica per adattarsi alla barra indirizzi che appare/scompare */
      display: grid; 
      grid-template-rows: auto 1fr; 
      position: relative;
    }

    /* --- HEADER --- */
    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(255,255,255,0.95);
      backdrop-filter: blur(10px); /* Effetto vetro tipico di iOS */
      border-bottom: 1px solid rgba(0,0,0,.1);
      box-shadow: 0 2px 10px rgba(0,0,0,.03);
      padding-top: var(--safe-top); /* Spazio per la tacca */
      transition: transform 0.3s ease;
    }

    /* Quando l'header √® chiuso (es. mentre scrivi) */
    header.collapsed {
      transform: translateY(calc(-100% + 24px + var(--safe-top)));
    }

    .headerInner {
      display: flex;
      gap: 8px;
      padding: 10px 12px;
      overflow-x: auto; /* Permette lo scroll orizzontale su schermi piccolissimi */
      scrollbar-width: none;
    }
    .headerInner::-webkit-scrollbar { display: none; }

    .headerHandle {
      width: 100%;
      height: 24px;
      background: rgba(0,0,0,.03);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .headerHandle::after { 
      content: ""; 
      width: 40px; 
      height: 4px; 
      background: rgba(0,0,0,0.2); 
      border-radius: 2px; 
    }

    /* --- BOTTONI GENERICI --- */
    .btn {
      background: #fff;
      border: 1px solid rgba(0,0,0,.15);
      border-radius: 10px;
      padding: 0 14px;
      height: 44px; /* Altezza minima per touch Apple */
      font-size: 15px;
      font-weight: 500;
      color: #333;
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active { background: #f0f0f0; transform: scale(0.98); }
    .btn.active { background: #eef6ff; border-color: var(--accent); color: var(--accent); }
    .btn.danger { color: #d32f2f; border-color: #ffcdd2; background: #fffafa; }

    /* Input colore custom */
    .color-wrapper {
      position: relative;
      width: 44px; height: 44px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.15);
    }
    input[type="color"] {
      position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
      border: 0; padding: 0; cursor: pointer;
    }

    /* --- BOARD E VIEWPORT --- */
    #board {
      position: relative;
      width: 100%; height: 100%;
      overflow: hidden;
      touch-action: none; /* Disabilita zoom/pan nativo del browser */
      cursor: grab;
      background-image: 
        radial-gradient(var(--grid) 1px, transparent 1px);
      background-size: 20px 20px;
    }
    #board:active { cursor: grabbing; }

    #viewport {
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      will-change: transform;
    }

    /* --- NODI (POPS) --- */
    .pop {
      position: absolute;
      width: 220px;
      background: #fff;
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.08), 0 0 0 1px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      border-left: 5px solid var(--accent);
      transition: box-shadow 0.2s, transform 0.1s;
    }
    .pop.selected {
      box-shadow: 0 8px 30px rgba(0,0,0,0.15), 0 0 0 2px var(--accent);
      z-index: 10;
    }

    textarea.body {
      width: 100%;
      border: none;
      outline: none;
      resize: none;
      font-family: inherit;
      font-size: 17px; /* 16px+ evita lo zoom automatico su iOS */
      line-height: 1.4;
      background: transparent;
      min-height: 24px;
      padding: 0;
      margin: 0;
    }

    /* --- SVG LINKS --- */
    svg#wires {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      overflow: visible;
    }
    .linkLine {
      stroke: #bbb; stroke-width: 2; fill: none; stroke-linecap: round;
      transition: stroke 0.2s;
    }
    .linkLine.selected { stroke: var(--accent); stroke-width: 3; }

    /* --- CONTROLLI FLOTTANTI --- */
    #controlsRight, #controlsLeft {
      position: fixed;
      bottom: var(--controls-bottom);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 90;
      pointer-events: none; /* Click passano attraverso l'area vuota */
    }
    #controlsRight { right: 16px; }
    #controlsLeft { left: 16px; }

    .btn-float {
      pointer-events: auto;
      width: 50px; height: 50px;
      border-radius: 50%;
      background: #fff;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      border: none;
      font-size: 22px;
      display: flex; align-items: center; justify-content: center;
      transition: transform 0.1s;
    }
    .btn-float:active { transform: scale(0.9); }
    .btn-float.active { background: var(--accent); color: #fff; }

    /* --- MODAL HELP --- */
    #overlayHelp {
      position: fixed; inset: 0; z-index: 2000;
      background: rgba(0,0,0,0.6); backdrop-filter: blur(4px);
      display: none; align-items: center; justify-content: center;
    }
    .modal {
      background: #fff; padding: 24px; width: 85%; max-width: 400px;
      border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    .shortcut-row { display: flex; justify-content: space-between; margin-bottom: 12px; border-bottom:1px solid #eee; padding-bottom:8px;}
    .key { background: #eee; padding: 2px 8px; border-radius: 6px; font-family: monospace; font-size: 14px; }
  </style>
</head>
<body>

<div id="app">
  <header id="mainHeader">
    <div class="headerInner">
      <button class="btn" id="btnNew">Ôºã Nuovo</button>
      <button class="btn danger" id="btnDelete">Elimina</button>
      <div class="color-wrapper">
        <input type="color" id="inputColor" value="#0078ff">
      </div>
      <div style="flex:1"></div>
      <button class="btn" id="btnExport">Salva</button>
      <button class="btn" id="btnImport">Apri</button>
      <button class="btn" id="btnHelp">?</button>
    </div>
    <div class="headerHandle" id="headerHandle"></div>
  </header>

  <div id="board">
    <div id="viewport">
      <svg id="wires"></svg>
      <div id="world"></div>
    </div>
  </div>

  <div id="controlsLeft">
    <button class="btn-float" id="btnLinkMode" title="Collega">üîó</button>
  </div>

  <div id="controlsRight">
    <button class="btn-float" id="btnZoomIn">Ôºã</button>
    <button class="btn-float" id="btnZoomOut">Ôºç</button>
    <button class="btn-float" id="btnFit">üéØ</button>
  </div>
</div>

<div id="overlayHelp">
  <div class="modal">
    <h3>Comandi</h3>
    <div class="shortcut-row"><span>Nuovo Pop</span> <span class="key">Doppio Click</span></div>
    <div class="shortcut-row"><span>Sposta Mappa</span> <span class="key">Trascinare sfondo</span></div>
    <div class="shortcut-row"><span>Sposta Pop</span> <span class="key">Trascinare pop</span></div>
    <div class="shortcut-row"><span>Zoom</span> <span class="key">Pizzica / +/-</span></div>
    <div class="shortcut-row"><span>Collega</span> <span class="key">Tasto üîó poi tocca altro pop</span></div>
    <br>
    <button class="btn" style="width:100%" id="btnCloseHelp">Chiudi</button>
  </div>
</div>

<input type="file" id="fileInput" accept=".json" style="display: none;" />

<script>
(function() {
  // --- STATO DELL'APP ---
  let pops = [];
  let links = [];
  let view = { x: 0, y: 0, scale: 1 };
  
  let selectedId = null;
  let linkMode = false;
  let linkingSourceId = null;
  
  // Elementi DOM
  const dom = {
    app: document.getElementById('app'),
    header: document.getElementById('mainHeader'),
    board: document.getElementById('board'),
    viewport: document.getElementById('viewport'),
    world: document.getElementById('world'),
    svg: document.getElementById('wires'),
    colorInput: document.getElementById('inputColor'),
    fileInput: document.getElementById('fileInput'),
    btnLink: document.getElementById('btnLinkMode')
  };

  // --- INIZIALIZZAZIONE ---
  function init() {
    // Carica dati se esistono (opzionale) o crea un nodo iniziale
    createPop(window.innerWidth / 2 - 110, window.innerHeight / 2 - 100, "Inizia qui...");
    centerView();
    setupEvents();
    loop();
  }

  // --- EVENT HANDLING ---
  function setupEvents() {
    // 1. Gestione PAN della mappa (Pointer Events per Mouse e Touch)
    let isPanning = false;
    let lastP = { x: 0, y: 0 };
    let pointers = []; // Per gestire il pinch-to-zoom
    let initDist = 0;
    let initScale = 1;

    dom.board.addEventListener('pointerdown', e => {
      // Se clicco su un pop o svg, non faccio pan
      if (e.target.closest('.pop')) return;
      
      dom.board.setPointerCapture(e.pointerId);
      pointers.push(e);
      
      if (pointers.length === 1) {
        isPanning = true;
        lastP = { x: e.clientX, y: e.clientY };
      } else if (pointers.length === 2) {
        // Inizio pinch
        isPanning = false;
        initDist = getDist(pointers[0], pointers[1]);
        initScale = view.scale;
      }
      
      // Deseleziona se clicco sullo sfondo
      if (e.target === dom.board || e.target === dom.viewport) {
        selectPop(null);
        dom.header.classList.remove('collapsed'); // Riapri header se clicco fuori
        document.activeElement.blur(); // Chiudi tastiera
      }
    });

    dom.board.addEventListener('pointermove', e => {
      // Aggiorna pointer cache
      const index = pointers.findIndex(p => p.pointerId === e.pointerId);
      if (index > -1) pointers[index] = e;

      if (pointers.length === 2) {
        // GESTIONE PINCH ZOOM
        const dist = getDist(pointers[0], pointers[1]);
        const mid = getMid(pointers[0], pointers[1]);
        const newScale = initScale * (dist / initDist);
        zoomAt(newScale, mid.x, mid.y);
        return;
      }

      if (isPanning && pointers.length === 1) {
        const dx = e.clientX - lastP.x;
        const dy = e.clientY - lastP.y;
        view.x += dx;
        view.y += dy;
        lastP = { x: e.clientX, y: e.clientY };
        applyView();
      }
    });

    const endPointer = (e) => {
      const index = pointers.findIndex(p => p.pointerId === e.pointerId);
      if (index > -1) pointers.splice(index, 1);
      if (pointers.length < 2) initDist = 0;
      if (pointers.length === 0) isPanning = false;
    };
    dom.board.addEventListener('pointerup', endPointer);
    dom.board.addEventListener('pointercancel', endPointer);

    // 2. Doppio click per creare nuovo nodo
    dom.board.addEventListener('dblclick', e => {
      if (e.target === dom.board || e.target === dom.viewport) {
        const wPos = screenToWorld(e.clientX, e.clientY);
        createPop(wPos.x - 110, wPos.y - 30); // Centra approssimativamente
      }
    });

    // 3. Header e Controlli
    document.getElementById('headerHandle').onclick = () => dom.header.classList.toggle('collapsed');
    document.getElementById('btnNew').onclick = () => {
      // Crea al centro dello schermo
      const c = screenToWorld(window.innerWidth/2, window.innerHeight/2);
      createPop(c.x - 110, c.y - 30);
    };
    document.getElementById('btnDelete').onclick = deleteSelected;
    
    // Zoom Buttons
    document.getElementById('btnZoomIn').onclick = () => zoomAt(view.scale * 1.2, window.innerWidth/2, window.innerHeight/2);
    document.getElementById('btnZoomOut').onclick = () => zoomAt(view.scale / 1.2, window.innerWidth/2, window.innerHeight/2);
    document.getElementById('btnFit').onclick = centerView;

    // Link Mode
    dom.btnLink.onclick = () => {
      if (!selectedId) {
        alert("Seleziona prima un nodo da cui partire.");
        return;
      }
      linkMode = !linkMode;
      linkingSourceId = selectedId;
      dom.btnLink.classList.toggle('active', linkMode);
    };

    // Color Picker
    dom.colorInput.oninput = (e) => {
      if (selectedId) {
        const p = pops.find(x => x.id === selectedId);
        if (p) { p.color = e.target.value; render(); }
      }
    };

    // Import/Export
    document.getElementById('btnExport').onclick = exportData;
    document.getElementById('btnImport').onclick = () => dom.fileInput.click();
    dom.fileInput.onchange = importData;

    // Help
    const help = document.getElementById('overlayHelp');
    document.getElementById('btnHelp').onclick = () => help.style.display = "flex";
    document.getElementById('btnCloseHelp').onclick = () => help.style.display = "none";
    help.onclick = (e) => { if(e.target === help) help.style.display = "none"; };
  }

  // --- LOGICA CORE ---

  function createPop(x, y, text = "") {
    const id = "p_" + Date.now() + Math.random().toString(16).slice(2);
    const p = { id, x, y, text, color: dom.colorInput.value };
    pops.push(p);
    render();
    selectPop(id);
    return id;
  }

  function deleteSelected() {
    if (!selectedId) return;
    if (!confirm("Eliminare questo elemento?")) return;
    
    pops = pops.filter(p => p.id !== selectedId);
    links = links.filter(l => l.from !== selectedId && l.to !== selectedId);
    selectPop(null);
    render();
  }

  function selectPop(id) {
    selectedId = id;
    render(); // Per aggiornare classi CSS
    
    if (id) {
      const p = pops.find(x => x.id === id);
      dom.colorInput.value = p.color;
    } else {
      linkMode = false;
      dom.btnLink.classList.remove('active');
    }
  }

  function render() {
    // Render Pops
    dom.world.innerHTML = "";
    pops.forEach(p => {
      const el = document.createElement('div');
      el.className = "pop";
      if (p.id === selectedId) el.classList.add('selected');
      el.style.left = p.x + "px";
      el.style.top = p.y + "px";
      el.style.borderLeftColor = p.color;

      const ta = document.createElement('textarea');
      ta.className = "body";
      ta.value = p.text;
      ta.placeholder = "Scrivi...";
      
      // Auto-resize
      ta.style.height = 'auto'; 
      setTimeout(() => ta.style.height = ta.scrollHeight + 'px', 0);

      // Eventi Input
      ta.addEventListener('input', (e) => {
        p.text = e.target.value;
        ta.style.height = 'auto';
        ta.style.height = ta.scrollHeight + 'px';
        renderLinks(); // Aggiorna linee se la dimensione cambia
      });

      // Eventi Focus per iPhone
      ta.addEventListener('focus', () => {
        selectPop(p.id);
        // Su mobile, chiudi header e centra
        if (window.innerWidth < 800) {
          dom.header.classList.add('collapsed');
          setTimeout(() => {
            el.scrollIntoView({ behavior: "smooth", block: "center", inline: "center" });
          }, 300);
        }
      });

      // Dragging del nodo
      el.addEventListener('pointerdown', e => {
        if (linkMode) {
          e.stopPropagation();
          if (linkingSourceId && linkingSourceId !== p.id) {
            links.push({ from: linkingSourceId, to: p.id });
            linkMode = false;
            dom.btnLink.classList.remove('active');
            renderLinks();
          }
          return;
        }

        if (e.target === ta) return; // Lascia gestire il focus al textarea

        selectPop(p.id);
        e.stopPropagation(); // Evita pan board
        el.setPointerCapture(e.pointerId);
        
        const startX = e.clientX;
        const startY = e.clientY;
        const origX = p.x;
        const origY = p.y;

        const onMove = (mv) => {
          const dx = (mv.clientX - startX) / view.scale;
          const dy = (mv.clientY - startY) / view.scale;
          p.x = origX + dx;
          p.y = origY + dy;
          el.style.left = p.x + "px";
          el.style.top = p.y + "px";
          renderLinks();
        };
        
        const onUp = () => {
          el.removeEventListener('pointermove', onMove);
          el.removeEventListener('pointerup', onUp);
        };
        
        el.addEventListener('pointermove', onMove);
        el.addEventListener('pointerup', onUp);
      });

      el.appendChild(ta);
      dom.world.appendChild(el);
    });

    renderLinks();
  }

  function renderLinks() {
    // Semplice rendering SVG
    let html = "";
    links.forEach(l => {
      const p1 = pops.find(x => x.id === l.from);
      const p2 = pops.find(x => x.id === l.to);
      if (!p1 || !p2) return;
      
      // Calcolo centro approssimativo (width=220 + padding)
      const x1 = p1.x + 120, y1 = p1.y + 40;
      const x2 = p2.x + 120, y2 = p2.y + 40;
      
      const isSel = (l.from === selectedId || l.to === selectedId);
      const cls = isSel ? "linkLine selected" : "linkLine";
      
      html += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="${cls}" />`;
    });
    dom.svg.innerHTML = html;
  }

  // --- UTILS VISTA ---
  function applyView() {
    dom.viewport.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
  }

  function screenToWorld(sx, sy) {
    return {
      x: (sx - view.x) / view.scale,
      y: (sy - view.y) / view.scale
    };
  }

  function zoomAt(newScale, screenX, screenY) {
    // Zoom verso il punto del mouse/dito
    const worldBefore = screenToWorld(screenX, screenY);
    view.scale = Math.max(0.1, Math.min(5, newScale));
    const worldAfter = screenToWorld(screenX, screenY);
    
    // Compensa lo spostamento
    view.x += (worldAfter.x - worldBefore.x) * view.scale;
    view.y += (worldAfter.y - worldBefore.y) * view.scale;
    
    applyView();
  }

  function getDist(p1, p2) {
    return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
  }
  
  function getMid(p1, p2) {
    return { x: (p1.clientX + p2.clientX)/2, y: (p1.clientY + p2.clientY)/2 };
  }

  function centerView() {
    if (pops.length === 0) {
      view.x = window.innerWidth/2; 
      view.y = window.innerHeight/2;
    } else {
      // Centra sul primo elemento o media
      const p = pops[0];
      view.x = (window.innerWidth/2) - (p.x * view.scale) - 110;
      view.y = (window.innerHeight/2) - (p.y * view.scale) - 40;
    }
    applyView();
  }

  function loop() {
    requestAnimationFrame(loop);
    // Loop per animazioni fluide se necessarie
  }

  // --- DATA ---
  function exportData() {
    const data = JSON.stringify({ version: 1, pops, links });
    const blob = new Blob([data], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = "mappa_mentale.json";
    a.click();
  }

  function importData(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (re) => {
      try {
        const d = JSON.parse(re.target.result);
        if (d.pops) pops = d.pops;
        if (d.links) links = d.links;
        render();
        centerView();
      } catch(err) { alert("Errore file"); }
    };
    reader.readAsText(file);
  }

  // Start
  init();

})();
</script>
</body>
</html>
